{"version":3,"file":"index.js","mappings":"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","sources":["webpack://comsync/webpack/universalModuleDefinition","webpack://comsync/external umd \"comlink\"","webpack://comsync/external umd \"sync-message\"","webpack://comsync/webpack/bootstrap","webpack://comsync/webpack/runtime/compat get default export","webpack://comsync/webpack/runtime/define property getters","webpack://comsync/webpack/runtime/hasOwnProperty shorthand","webpack://comsync/webpack/runtime/make namespace object","webpack://comsync/./lib/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"sync-message\"), require(\"comlink\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"sync-message\", \"comlink\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"comsync\"] = factory(require(\"sync-message\"), require(\"comlink\"));\n\telse\n\t\troot[\"comsync\"] = factory(root[\"sync-message\"], root[\"comlink\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__746__, __WEBPACK_EXTERNAL_MODULE__272__) {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__272__;","module.exports = __WEBPACK_EXTERNAL_MODULE__746__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {Channel, readMessage, uuidv4, writeMessage} from \"sync-message\";\nimport * as Comlink from \"comlink\";\n\nexport class InterruptError extends Error {\n  // To avoid having to use instanceof\n  public readonly type = \"InterruptError\";\n  public readonly name = this.type;\n}\n\nexport class NoChannelError extends Error {\n  // To avoid having to use instanceof\n  public readonly type = \"NoChannelError\";\n  public readonly name = this.type;\n}\n\nexport class SyncClient<T = any> {\n  public interrupter?: () => void;\n  public state: \"idle\" | \"running\" | \"awaitingMessage\" | \"sleeping\" = \"idle\";\n  public worker: Worker;\n  public workerProxy: Comlink.Remote<T>;\n\n  private _interruptRejector?: (reason?: any) => void;\n  private _interruptPromise?: Promise<void>;\n\n  private _messageIdBase = \"\";\n  private _messageIdSeq = 0;\n\n  private _awaitingMessageResolve?: () => void;\n\n  public constructor(\n    public workerCreator: () => Worker,\n    public channel?: Channel | null,\n  ) {\n    this._start();\n  }\n\n  public async interrupt() {\n    if (this.state === \"idle\") {\n      return;\n    }\n\n    if (this.state === \"awaitingMessage\" || this.state === \"sleeping\") {\n      await this._writeMessage({interrupted: true});\n      return;\n    }\n\n    if (this.interrupter) {\n      await this.interrupter();\n      return;\n    }\n\n    this.terminate();\n    this._start();\n  }\n\n  public async call(proxyMethod: any, ...args: any[]) {\n    if (this.state !== \"idle\") {\n      throw new Error(`State is ${this.state}, not idle`);\n    }\n\n    let runningThisTask = true;\n    this.state = \"running\";\n\n    this._messageIdBase = uuidv4();\n    this._messageIdSeq = 0;\n\n    const syncMessageCallback: SyncMessageCallback = (status) => {\n      if (!runningThisTask || status === \"init\") {\n        return;\n      }\n\n      if (status === \"reading\") {\n        this.state = \"awaitingMessage\";\n        this._messageIdSeq++;\n        this._awaitingMessageResolve?.();\n      } else if (status === \"sleeping\") {\n        this.state = \"sleeping\";\n        this._messageIdSeq++;\n      } else if (status === \"slept\") {\n        this.state = \"running\";\n      }\n    };\n\n    this._interruptPromise = new Promise(\n      (resolve, reject) => (this._interruptRejector = reject),\n    );\n\n    try {\n      return await Promise.race([\n        proxyMethod(\n          this.channel,\n          Comlink.proxy(syncMessageCallback),\n          this._messageIdBase,\n          ...args,\n        ),\n        this._interruptPromise,\n      ]);\n    } finally {\n      runningThisTask = false;\n      this._reset();\n    }\n  }\n\n  public async writeMessage(message: any) {\n    if (this.state === \"idle\" || !this._messageIdBase) {\n      throw new Error(\"No active call to send a message to.\");\n    }\n\n    if (this.state !== \"awaitingMessage\") {\n      if (this._awaitingMessageResolve) {\n        throw new Error(\n          \"Not waiting for message, and another write is already queued.\",\n        );\n      }\n\n      await new Promise<void>((resolve) => {\n        this._awaitingMessageResolve = resolve;\n      });\n      delete this._awaitingMessageResolve;\n    }\n\n    await this._writeMessage({message});\n  }\n\n  public terminate() {\n    this._interruptRejector?.(new InterruptError(\"Worker terminated\"));\n    this.workerProxy[Comlink.releaseProxy]();\n    this.worker.terminate();\n    delete this.workerProxy;\n    delete this.worker;\n  }\n\n  private async _writeMessage(message: any) {\n    this.state = \"running\";\n    const messageId = makeMessageId(this._messageIdBase, this._messageIdSeq);\n    await writeMessage(this.channel, message, messageId);\n  }\n\n  private _start() {\n    this._reset();\n    this.worker = this.workerCreator();\n    this.workerProxy = Comlink.wrap<T>(this.worker);\n  }\n\n  private _reset() {\n    this.state = \"idle\";\n    delete this._interruptPromise;\n    delete this._interruptRejector;\n    delete this._awaitingMessageResolve;\n    delete this._messageIdBase;\n  }\n}\n\nexport interface SyncExtras {\n  channel: Channel | null;\n  readMessage: () => any;\n  syncSleep: (ms: number) => void;\n}\n\ntype SyncMessageCallbackStatus = \"init\" | \"reading\" | \"sleeping\" | \"slept\";\ntype SyncMessageCallback = (status: SyncMessageCallbackStatus) => void;\n\nexport function syncExpose<T extends any[], R>(\n  func: (extras: SyncExtras, ...args: T) => R,\n) {\n  return async function (\n    channel: Channel | null,\n    syncMessageCallback: SyncMessageCallback,\n    messageIdBase: string,\n    ...args: T\n  ): Promise<R> {\n    await syncMessageCallback(\"init\");\n    let messageIdSeq = 0;\n\n    function fullSyncMessageCallback(\n      status: \"reading\" | \"sleeping\",\n      options?: {timeout: number},\n    ) {\n      if (!channel) {\n        throw new NoChannelError();\n      }\n      syncMessageCallback(status);\n      const messageId = makeMessageId(messageIdBase, ++messageIdSeq);\n      const response = readMessage(channel, messageId, options);\n      if (response) {\n        const {message, interrupted} = response;\n        if (interrupted) {\n          throw new InterruptError();\n        }\n        return message;\n      } else if (status === \"sleeping\") {\n        syncMessageCallback(\"slept\");\n      }\n    }\n\n    const extras: SyncExtras = {\n      channel,\n      readMessage() {\n        return fullSyncMessageCallback(\"reading\");\n      },\n      syncSleep(ms: number) {\n        if (!(ms > 0)) {\n          return;\n        }\n        fullSyncMessageCallback(\"sleeping\", {timeout: ms});\n      },\n    };\n    return func(extras, ...args);\n  };\n}\n\nfunction makeMessageId(base: string, seq: number) {\n  return `${base}-${seq}`;\n}\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__746__","__WEBPACK_EXTERNAL_MODULE__272__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","InterruptError","Error","type","name","this","NoChannelError","SyncClient","workerCreator","channel","state","_messageIdBase","_messageIdSeq","_start","interrupt","interrupter","terminate","_writeMessage","interrupted","proxyMethod","args","runningThisTask","uuidv4","syncMessageCallback","status","_awaitingMessageResolve","_interruptPromise","Promise","resolve","reject","_interruptRejector","race","_reset","writeMessage","message","workerProxy","worker","messageId","makeMessageId","syncExpose","func","messageIdBase","messageIdSeq","fullSyncMessageCallback","options","response","readMessage","syncSleep","ms","timeout","base","seq"],"sourceRoot":""}