{"version":3,"file":"index.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAqB,YAAID,IAEzBD,EAAkB,YAAIC,IARxB,CASGK,MAAM,WACT,M,mBCTA,IAAIC,EAAsB,CCA1BA,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3EF,EAAwB,CAACQ,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFT,EAAyBL,IACH,oBAAXkB,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeV,EAASkB,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeV,EAAS,aAAc,CAAEoB,OAAO,M,6mBCLvD,MAAMC,EAAkB,oCAClBC,EAAU,sBAoBT,SAASC,EAAuBC,GAIrC,MAHuB,iBAAZA,IACTA,EAAUA,EAAQA,QAAQC,KAErBD,EAAQE,SAASL,GAQnB,SAASM,IACd,MAAMC,EAA4C,GAC5CC,EAA0D,GAEhE,OAAQC,IACN,MAAM,IAACL,GAAOK,EAAEN,QAChB,QAAKD,EAAuBE,KAiD5BK,EAAEC,YA7CF,W,yCACE,SAASC,EAAQC,GACf,MAAMC,EAAkC,CAACD,QAAAA,EAASE,QAASb,GAC3D,OAAO,IAAIc,SAASC,KAAKC,UAAUJ,GAAW,CAACK,OAAQ,MAGzD,GAAId,EAAIe,SAAS,SAAU,CACzB,MAAM,UACJC,EAAS,QACTC,SACkCZ,EAAEN,QAAQmB,OAC9C,GAAIF,KAAab,EAAe,CAC9B,MAAMK,EAAUL,EAAca,GAE9B,cADOb,EAAca,GACdT,EAAQC,GAEf,aAAa,IAAIW,SAASC,IACxBhB,EAAUY,GAAaI,EAOvBC,YALA,kBACSjB,EAAUY,GACjBI,EAAS,IAAIT,SAAS,GAAI,CAACG,OAAQ,SAGhBG,MAGpB,GAAIjB,EAAIe,SAAS,UAAW,CACjC,MAAM,QACJP,EAAO,UACPQ,SACmCX,EAAEN,QAAQmB,OACzCE,EAAWhB,EAAUY,GAO3B,OANII,GACFA,EAASb,EAAQC,WACVJ,EAAUY,IAEjBb,EAAca,GAAaR,EAEtBD,EAAQ,CAACe,OAAQF,IACnB,GAAIpB,EAAIe,SAAS,YACtB,OAAO,IAAIJ,SAASd,EAAS,CAACiB,OAAQ,SAI5BS,KACP,IAQJ,SAASC,EAAWC,GACzB,OAAO,IAAIN,SAASO,GAAYL,WAAWK,EAASD,KA0C/C,MAAME,UAA2BC,MAItCC,YAAmB7B,EAAoBc,GACrCgB,MACE,mBAAmBhB,UAAed,0DAFnB,KAAAA,IAAAA,EAAoB,KAAAc,OAAAA,EAFvB,KAAAiB,KAAO,qBAOrB/C,OAAOgD,eAAeC,KAAMN,EAAmBrC,YAM5C,SAAS4C,EAAoBC,EAAyB3B,GAC3D,MACM4B,GADU,IAAIC,aACEC,OAAO1B,KAAKC,UAAUL,KACtC,KAAC+B,EAAI,KAAEC,GAAQL,EACrB,GAAIC,EAAMK,OAASF,EAAKE,OACtB,MAAM,IAAIb,MACR,gEAGJW,EAAKG,IAAIN,EAAO,GAChBO,QAAQC,MAAMJ,EAAM,EAAGJ,EAAMK,QAC7BE,QAAQC,MAAMJ,EAAM,EAAG,GACvBG,QAAQE,OAAOL,EAAM,GAGhB,SAAeM,EACpBX,EACA3B,EACAQ,G,+CAEM+B,UAAUC,cAAcC,MAC9B,MAAMjD,EAAMmC,EAAQe,QAAU,SACxBC,EAAYC,KAAKC,MACvB,OAAa,CACX,MAAMtD,EAAqC,CAACS,QAAAA,EAASQ,UAAAA,GAC/CP,QAAiB6C,MAAMtD,EAAK,CAChCuD,OAAQ,OACRC,KAAM5C,KAAKC,UAAUd,KAEvB,GACsB,MAApBU,EAASK,eACFL,EAASS,QAAQR,UAAYb,EAEpC,OAEF,KAAIuD,KAAKC,MAAQF,EAAYhB,EAAQlB,SAIrC,MAAM,IAAIU,EAAmB3B,EAAKS,EAASK,cAHnCU,EAAW,SAgBhB,SAAeiC,EACpBtB,EACA3B,EACAQ,G,yCAEqB,YAAjBmB,EAAQJ,KACVG,EAAoBC,EAAS3B,SAEvBsC,EAA0BX,EAAS3B,EAASQ,MAsB/C,SAAS0C,EACdC,EAGI,IAEJ,MAAiC,oBAAtBC,kBACFC,EAAmBF,EAAQG,SACzB,kBAAmBf,UACrBgB,EAAyBJ,EAAQX,eAEjC,KAIJ,SAASa,GAAmB,WACjCG,GACyB,IAKzB,MAAO,CAACjC,KAAM,UAAWQ,KAJZ,IAAI0B,WAAW,IAAIL,kBAAkBI,GAAc,SAIjCxB,KAHlB,IAAI0B,WACf,IAAIN,kBAAiD,EAA/BM,WAAWC,qBAK9B,SAASJ,EACdJ,EAAuC,IAGvC,MAAO,CAAC5B,KAAM,gBAAiBmB,SADdS,EAAQS,OAAS,KAAOxE,EACDqB,QAAS0C,EAAQ1C,SAAW,KAGtE,SAASoD,EAAqBC,EAAWC,GACvC,OAAOD,EAAI,GAAKA,EAAIC,EAkBf,SAASC,EACdrC,EACAnB,GACA,eACEyD,EAAc,aACdC,EAAY,QACZzD,GAKE,IAEJ,MAAMkC,EAAYwB,YAAYtB,MAE9BqB,EAAeL,EACbK,EACAD,EAAiB,IAAM,KAEzB,MAAMG,EAAeP,EAAqBpD,EAAS4D,OAAOC,mBAC1D,IAAIC,EAEJ,GAAqB,YAAjB5C,EAAQJ,KAAoB,CAC9B,MAAM,KAACQ,EAAI,KAAEC,GAAQL,EAErB4C,EAAQ,KACN,GAA+C,cAA3CpC,QAAQqC,KAAKxC,EAAM,EAAG,EAAGkC,GAC3B,OAAO,KACF,CACL,MAAMO,EAAOtC,QAAQuC,SAAS1C,EAAM,EAAG,GACjCJ,EAAQG,EAAK4C,MAAM,EAAGF,GAC5BtC,QAAQC,MAAMJ,EAAM,EAAG,GAEvB,MACM4C,GADU,IAAIC,aACCC,OAAOlD,GAC5B,OAAOxB,KAAK2E,MAAMH,UAItBL,EAAQ,KACN,MAAMhF,EAAU,IAAIyF,eAEdxF,EAAMmC,EAAQe,QAAU,QAC9BnD,EAAQ0F,KAAK,OAAQzF,GAAK,GAC1B,MAAM0F,EAAwC,CAC5C1E,UAAAA,EACAC,QAASyD,GAEX3E,EAAQ4F,KAAK/E,KAAKC,UAAU6E,IAC5B,MAAM,OAAC5E,GAAUf,EAEjB,GAAe,MAAXe,EACF,OAAO,KACF,GAAe,MAAXA,EAAgB,CACzB,MAAML,EAAWG,KAAK2E,MAAMxF,EAAQ6F,cACpC,OAAInF,EAASC,UAAYb,EAChB,KAEFY,EAASD,QACX,GAAImE,YAAYtB,MAAQF,EAAYhB,EAAQlB,QACjD,OAAO,KAEP,MAAM,IAAIU,EAAmB3B,EAAKc,IAKxC,OAAa,CACX,MACM+E,EAAYjB,GADFD,YAAYtB,MAAQF,GAEpC,GAAI0C,GAAa,EACf,OAAO,KAGTnB,EAAeoB,KAAKC,IAAIrB,EAAcmB,GACtC,MAAMG,EAASjB,IAEf,GAAe,OAAXiB,EACF,OAAOA,EACF,GAAIvB,MAAAA,OAAc,EAAdA,IACT,OAAO,MASN,SAASwB,EAAUxE,EAAYU,GAEpC,GADAV,EAAK4C,EAAqB5C,EAAI,GAK9B,GAAiC,oBAAtBmC,kBAAmC,CAC5C,MAAMsC,EAAM,IAAIhC,WACd,IAAIN,kBAAkBM,WAAWC,oBAEnC+B,EAAI,GAAK,EACTvD,QAAQqC,KAAKkB,EAAK,EAAG,EAAGzE,QAGxB+C,EAAYrC,EADM,SAASV,KAAM0E,MACD,CAAClF,QAASQ,IASvC,IAAI0E,E,OAGTA,EADE,eAAgBC,OACT,WACP,OAAQA,OAAeC,cAIhB,WACP,MAAO,uCAAuCC,QAAQ,UAAWC,IAC/D,MAAMC,EAAI3B,OAAO0B,GACjB,OACEC,EACCJ,OAAOK,gBAAgB,IAAIxC,WAAW,IAAI,GAAM,IAAOuC,EAAI,GAC5DE,SAAS,Q","sources":["webpack://syncMessage/webpack/universalModuleDefinition","webpack://syncMessage/webpack/bootstrap","webpack://syncMessage/webpack/runtime/define property getters","webpack://syncMessage/webpack/runtime/hasOwnProperty shorthand","webpack://syncMessage/webpack/runtime/make namespace object","webpack://syncMessage/./lib/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"syncMessage\"] = factory();\n\telse\n\t\troot[\"syncMessage\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const BASE_URL_SUFFIX = \"__SyncMessageServiceWorkerInput__\";\nconst VERSION = \"__sync-message-v2__\";\n\ninterface ServiceWorkerReadRequest {\n  messageId: string;\n  timeout: number;\n}\n\ninterface ServiceWorkerWriteRequest {\n  messageId: string;\n  message: string;\n}\n\ninterface ServiceWorkerResponse {\n  message: any;\n  version: string;\n}\n\n/**\n * Checks whether the given request is meant to be intercepted by the sync-message serviceWorkerFetchListener.\n */\nexport function isServiceWorkerRequest(request: FetchEvent | string): boolean {\n  if (typeof request !== \"string\") {\n    request = request.request.url;\n  }\n  return request.includes(BASE_URL_SUFFIX);\n}\n\n/**\n * Returns a function that can respond to fetch events in a service worker event listener.\n * The function returns true if the request came from this library and it responded.\n * Call `serviceWorkerFetchListener` and reuse the returned function as it manages internal state.\n */\nexport function serviceWorkerFetchListener(): (e: FetchEvent) => boolean {\n  const earlyMessages: {[messageId: string]: any} = {};\n  const resolvers: {[messageId: string]: (r: Response) => void} = {};\n\n  return (e: FetchEvent): boolean => {\n    const {url} = e.request;\n    if (!isServiceWorkerRequest(url)) {\n      return false;\n    }\n\n    async function respond(): Promise<Response> {\n      function success(message: any) {\n        const response: ServiceWorkerResponse = {message, version: VERSION};\n        return new Response(JSON.stringify(response), {status: 200});\n      }\n\n      if (url.endsWith(\"/read\")) {\n        const {\n          messageId,\n          timeout,\n        }: ServiceWorkerReadRequest = await e.request.json();\n        if (messageId in earlyMessages) {\n          const message = earlyMessages[messageId];\n          delete earlyMessages[messageId];\n          return success(message);\n        } else {\n          return await new Promise((resolver) => {\n            resolvers[messageId] = resolver;\n\n            function callback() {\n              delete resolvers[messageId];\n              resolver(new Response(\"\", {status: 408})); // timeout\n            }\n\n            setTimeout(callback, timeout);\n          });\n        }\n      } else if (url.endsWith(\"/write\")) {\n        const {\n          message,\n          messageId,\n        }: ServiceWorkerWriteRequest = await e.request.json();\n        const resolver = resolvers[messageId];\n        if (resolver) {\n          resolver(success(message));\n          delete resolvers[messageId];\n        } else {\n          earlyMessages[messageId] = message;\n        }\n        return success({early: !resolver});\n      } else if (url.endsWith(\"/version\")) {\n        return new Response(VERSION, {status: 200});\n      }\n    }\n\n    e.respondWith(respond());\n    return true;\n  };\n}\n\n/**\n * Convenience function that allows writing `await asyncSleep(1000)`\n * to wait one second before continuing in an async function.\n */\nexport function asyncSleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Options for making an atomics type channel.\n */\nexport interface AtomicsChannelOptions {\n  // The number of bytes to allocate for the `SharedArrayBuffer`.\n  // Defaults to 128KiB.\n  // `writeMessage` will throw an error if the message is larger than the buffer size.\n  bufferSize?: number;\n}\n\n/**\n * Options for making a serviceWorker type channel.\n */\nexport interface ServiceWorkerChannelOptions {\n  // a string representing the prefix of a path/URL, defaulting to `\"/\"`.\n  // Both `readMessage` and `writeMessage` will make requests that start with this value\n  // so make sure that your service worker is controlling the page and can intercept those requests.\n  // The `scope` property of the registration object returned by `navigator.serviceWorker.register` should work.\n  scope?: string;\n\n  // number of milliseconds representing a grace period for the service worker to start up.\n  // If requests made by `readMessage` and `writeMessage` fail,\n  // they will be retried until this timeout is exceeded,\n  // at which point they will throw an error.\n  timeout?: number;\n}\n\ninterface AtomicsChannel {\n  type: \"atomics\";\n  data: Uint8Array;\n  meta: Int32Array;\n}\n\ninterface ServiceWorkerChannel {\n  type: \"serviceWorker\";\n  baseUrl: string;\n  timeout: number;\n}\n\nexport class ServiceWorkerError extends Error {\n  // To avoid having to use instanceof\n  public readonly type = \"ServiceWorkerError\";\n\n  constructor(public url: string, public status: number) {\n    super(\n      `Received status ${status} from ${url}. Ensure the service worker is registered and active.`,\n    );\n    // See https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work for info about this workaround.\n    Object.setPrototypeOf(this, ServiceWorkerError.prototype);\n  }\n}\n\nexport type Channel = AtomicsChannel | ServiceWorkerChannel;\n\nexport function writeMessageAtomics(channel: AtomicsChannel, message: any) {\n  const encoder = new TextEncoder();\n  const bytes = encoder.encode(JSON.stringify(message));\n  const {data, meta} = channel;\n  if (bytes.length > data.length) {\n    throw new Error(\n      \"Message is too big, increase bufferSize when making channel.\",\n    );\n  }\n  data.set(bytes, 0);\n  Atomics.store(meta, 0, bytes.length);\n  Atomics.store(meta, 1, 1);\n  Atomics.notify(meta, 1);\n}\n\nexport async function writeMessageServiceWorker(\n  channel: ServiceWorkerChannel,\n  message: any,\n  messageId: string,\n) {\n  await navigator.serviceWorker.ready;\n  const url = channel.baseUrl + \"/write\";\n  const startTime = Date.now();\n  while (true) {\n    const request: ServiceWorkerWriteRequest = {message, messageId};\n    const response = await fetch(url, {\n      method: \"POST\",\n      body: JSON.stringify(request),\n    });\n    if (\n      response.status === 200 &&\n      (await response.json()).version === VERSION\n    ) {\n      return;\n    }\n    if (Date.now() - startTime < channel.timeout) {\n      await asyncSleep(100);\n      continue;\n    }\n    throw new ServiceWorkerError(url, response.status);\n  }\n}\n\n/**\n * Call this in the browser's main UI thread\n * to send a message to the worker reading from the channel with `readMessage`.\n *\n * @param channel a non-null object returned by `makeChannel`, `makeAtomicsChannel`, or `makeServiceWorkerChannel`.\n * @param message any object that can be safely passed to `JSON.stringify` and then decoded with `JSON.parse`.\n * @param messageId a unique string identifying the message that the worker is waiting for.\n *                  Currently only used by service worker channels.\n */\nexport async function writeMessage(\n  channel: Channel,\n  message: any,\n  messageId: string,\n) {\n  if (channel.type === \"atomics\") {\n    writeMessageAtomics(channel, message);\n  } else {\n    await writeMessageServiceWorker(channel, message, messageId);\n  }\n}\n\n/**\n * Accepts one optional argument `options` with optional keys for configuring the different types of channel.\n * See the types `AtomicsChannelOptions` and `ServiceWorkerChannelOptions` for more info.\n *\n * If `SharedArrayBuffer` is available, `makeChannel` will use it to create an `atomics` type channel.\n * Otherwise, if `navigator.serviceWorker` is available, it will create a `serviceWorker` type channel,\n * but registering the service worker is up to you.\n * If that's not available either, it'll return `null`.\n *\n * Channel objects have a `type` property which is either `\"atomics\"` or `\"serviceWorker\"`.\n * The other properties are for internal use.\n *\n * If you want to control the type of channel,\n * you can call `makeAtomicsChannel` or `makeServiceWorkerChannel` directly.\n *\n * A single channel object shouldn't be used by multiple workers simultaneously,\n * i.e. you should only read/write one message at a time.\n */\nexport function makeChannel(\n  options: {\n    atomics?: AtomicsChannelOptions;\n    serviceWorker?: ServiceWorkerChannelOptions;\n  } = {},\n): Channel | null {\n  if (typeof SharedArrayBuffer !== \"undefined\") {\n    return makeAtomicsChannel(options.atomics);\n  } else if (\"serviceWorker\" in navigator) {\n    return makeServiceWorkerChannel(options.serviceWorker);\n  } else {\n    return null;\n  }\n}\n\nexport function makeAtomicsChannel({\n  bufferSize,\n}: AtomicsChannelOptions = {}): AtomicsChannel {\n  const data = new Uint8Array(new SharedArrayBuffer(bufferSize || 128 * 1024));\n  const meta = new Int32Array(\n    new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * 2),\n  );\n  return {type: \"atomics\", data, meta};\n}\n\nexport function makeServiceWorkerChannel(\n  options: ServiceWorkerChannelOptions = {},\n): ServiceWorkerChannel {\n  const baseUrl = (options.scope || \"/\") + BASE_URL_SUFFIX;\n  return {type: \"serviceWorker\", baseUrl, timeout: options.timeout || 5000};\n}\n\nfunction ensurePositiveNumber(n: number, defaultValue: number) {\n  return n > 0 ? +n : defaultValue;\n}\n\n/**\n * Call this in a web worker to synchronously receive a message sent by the main thread with `writeMessage`.\n *\n * @param channel a non-null object returned by `makeChannel`, `makeAtomicsChannel`, or `makeServiceWorkerChannel`.\n *                Should be created once in the main thread and then sent to the worker.\n * @param messageId a unique string identifying the message that the worker is waiting for.\n *                  Currently only used by service worker channels.\n *                  Typically created in the worker using the `uuidv4` function and then sent to the main thread\n *                  *before* calling `readMessage`.\n * @param checkInterrupt a function which may be called regularly while `readMessage`\n *                       is checking for messages on the channel.\n *                       If it returns `true`, then `readMessage` will return `null`.\n * @param timeout a number of milliseconds.\n *                If this much time elapses without receiving a message, `readMessage` will return `null`.\n */\nexport function readMessage(\n  channel: Channel,\n  messageId: string,\n  {\n    checkInterrupt,\n    checkTimeout,\n    timeout,\n  }: {\n    checkInterrupt?: () => boolean;\n    checkTimeout?: number;\n    timeout?: number;\n  } = {},\n) {\n  const startTime = performance.now();\n\n  checkTimeout = ensurePositiveNumber(\n    checkTimeout,\n    checkInterrupt ? 100 : 5000,\n  );\n  const totalTimeout = ensurePositiveNumber(timeout, Number.POSITIVE_INFINITY);\n  let check;\n\n  if (channel.type === \"atomics\") {\n    const {data, meta} = channel;\n\n    check = () => {\n      if (Atomics.wait(meta, 1, 0, checkTimeout) === \"timed-out\") {\n        return null;\n      } else {\n        const size = Atomics.exchange(meta, 0, 0);\n        const bytes = data.slice(0, size);\n        Atomics.store(meta, 1, 0);\n\n        const decoder = new TextDecoder();\n        const text = decoder.decode(bytes);\n        return JSON.parse(text);\n      }\n    };\n  } else {\n    check = () => {\n      const request = new XMLHttpRequest();\n      // `false` makes the request synchronous\n      const url = channel.baseUrl + \"/read\";\n      request.open(\"POST\", url, false);\n      const requestBody: ServiceWorkerReadRequest = {\n        messageId,\n        timeout: checkTimeout,\n      };\n      request.send(JSON.stringify(requestBody));\n      const {status} = request;\n\n      if (status === 408) {\n        return null;\n      } else if (status === 200) {\n        const response = JSON.parse(request.responseText);\n        if (response.version !== VERSION) {\n          return null;\n        }\n        return response.message;\n      } else if (performance.now() - startTime < channel.timeout) {\n        return null;\n      } else {\n        throw new ServiceWorkerError(url, status);\n      }\n    };\n  }\n\n  while (true) {\n    const elapsed = performance.now() - startTime;\n    const remaining = totalTimeout - elapsed;\n    if (remaining <= 0) {\n      return null;\n    }\n\n    checkTimeout = Math.min(checkTimeout, remaining);\n    const result = check();\n\n    if (result !== null) {\n      return result;\n    } else if (checkInterrupt?.()) {\n      return null;\n    }\n  }\n}\n\n/**\n * Synchronously waits until the given time has elapsed without wasting CPU in a busy loop,\n * but not very accurate.\n */\nexport function syncSleep(ms: number, channel: Channel) {\n  ms = ensurePositiveNumber(ms, 0);\n  if (!ms) {\n    return;\n  }\n\n  if (typeof SharedArrayBuffer !== \"undefined\") {\n    const arr = new Int32Array(\n      new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT),\n    );\n    arr[0] = 0;\n    Atomics.wait(arr, 0, 0, ms);\n  } else {\n    const messageId = `sleep ${ms} ${uuidv4()}`;\n    readMessage(channel, messageId, {timeout: ms});\n  }\n}\n\n/**\n * Returns a unique random string in UUID v4 format.\n * Uses `crypto.randomUUID` directly if possible.\n * Otherwise uses a custom implementation which uses `crypto.getRandomValues`.\n */\nexport let uuidv4: () => string;\n\nif (\"randomUUID\" in crypto) {\n  uuidv4 = function uuidv4() {\n    return (crypto as any).randomUUID();\n  };\n} else {\n  // https://stackoverflow.com/a/2117523/2482744\n  uuidv4 = function uuidv4() {\n    return \"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, (char) => {\n      const c = Number(char);\n      return (\n        c ^\n        (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))\n      ).toString(16);\n    });\n  };\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","BASE_URL_SUFFIX","VERSION","isServiceWorkerRequest","request","url","includes","serviceWorkerFetchListener","earlyMessages","resolvers","e","respondWith","success","message","response","version","Response","JSON","stringify","status","endsWith","messageId","timeout","json","Promise","resolver","setTimeout","early","respond","asyncSleep","ms","resolve","ServiceWorkerError","Error","constructor","super","type","setPrototypeOf","this","writeMessageAtomics","channel","bytes","TextEncoder","encode","data","meta","length","set","Atomics","store","notify","writeMessageServiceWorker","navigator","serviceWorker","ready","baseUrl","startTime","Date","now","fetch","method","body","writeMessage","makeChannel","options","SharedArrayBuffer","makeAtomicsChannel","atomics","makeServiceWorkerChannel","bufferSize","Uint8Array","Int32Array","BYTES_PER_ELEMENT","scope","ensurePositiveNumber","n","defaultValue","readMessage","checkInterrupt","checkTimeout","performance","totalTimeout","Number","POSITIVE_INFINITY","check","wait","size","exchange","slice","text","TextDecoder","decode","parse","XMLHttpRequest","open","requestBody","send","responseText","remaining","Math","min","result","syncSleep","arr","uuidv4","crypto","randomUUID","replace","char","c","getRandomValues","toString"],"sourceRoot":""}