!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("comsync"),require("comlink"),require("pyodide")):"function"==typeof define&&define.amd?define(["comsync","comlink","pyodide"],e):"object"==typeof exports?exports["pyodide-worker-runner"]=e(require("comsync"),require("comlink"),require("pyodide")):t["pyodide-worker-runner"]=e(t.comsync,t.comlink,t.pyodide)}(self,((t,e,o)=>(()=>{var r={237:(t,e,o)=>{"use strict";o.d(e,{Z:()=>r});const r='import importlib\nimport sys\nfrom typing import Callable, Literal, Union, TypedDict\n\ntry:\n    from pyodide.code import find_imports  # noqa\nexcept ImportError:\n    from pyodide import find_imports  # noqa\n\nimport pyodide_js  # noqa\n\nsys.setrecursionlimit(400)\n\n\nclass InstallEntry(TypedDict):\n    module: str\n    package: str\n\n\ndef find_imports_to_install(imports: list[str]) -> list[InstallEntry]:\n    """\n    Given a list of module names being imported, return a list of dicts\n    representing the packages that need to be installed to import those modules.\n    The returned list will only contain modules that aren\'t already installed.\n    Each returned dict has the following keys:\n      - module: the name of the module being imported\n      - package: the name of the package that needs to be installed\n    """\n    try:\n        to_package_name = pyodide_js._module._import_name_to_package_name.to_py()\n    except AttributeError:\n        to_package_name = pyodide_js._api._import_name_to_package_name.to_py()\n\n    to_install: list[InstallEntry] = []\n    for module in imports:\n        try:\n            importlib.import_module(module)\n        except ModuleNotFoundError:\n            to_install.append(\n                dict(\n                    module=module,\n                    package=to_package_name.get(module, module),\n                )\n            )\n    return to_install\n\n\nasync def install_imports(\n    source_code_or_imports: Union[str, list[str]],\n    message_callback: Callable[\n        [\n            Literal[\n                "loading_all",\n                "loaded_all",\n                "loading_one",\n                "loaded_one",\n                "loading_micropip",\n                "loaded_micropip",\n            ],\n            Union[InstallEntry, list[InstallEntry]],\n        ],\n        None,\n    ] = lambda event_type, data: None,\n):\n    """\n    Accepts a string of Python source code or a list of module names being imported.\n    Installs any packages that need to be installed to import those modules,\n    using micropip, which may also be installed if needed.\n    If the package is not specially built for Pyodide, it must be available on PyPI\n    as a pure Python wheel file.\n    If the `message_callback` argument is provided, it will be called with an\n    event type and data about the packages being installed.\n    The event types start with `loading_` before installation, and `loaded_` after.\n    The data is either a single dict representing the package being installed,\n    or a list of all the packages being installed.\n    The events are:\n        - loading/loaded_all, with a list of all the packages being installed.\n        - loading/loaded_one, with a dict for a single package.\n        - loading/loaded_micropip, with a dict for the special micropip package.\n    """\n    if isinstance(source_code_or_imports, str):\n        try:\n            imports: list[str] = find_imports(source_code_or_imports)\n        except SyntaxError:\n            return\n    else:\n        imports: list[str] = source_code_or_imports\n\n    to_install = find_imports_to_install(imports)\n    if to_install:\n        message_callback("loading_all", to_install)\n        try:\n            import micropip  # noqa\n        except ModuleNotFoundError:\n            micropip_entry = dict(module="micropip", package="micropip")\n            message_callback("loading_micropip", micropip_entry)\n            await pyodide_js.loadPackage("micropip")\n            import micropip  # noqa\n\n            message_callback("loaded_micropip", micropip_entry)\n\n        for entry in to_install:\n            message_callback("loading_one", entry)\n            await micropip.install(entry["package"])\n            message_callback("loaded_one", entry)\n        message_callback("loaded_all", to_install)\n'},353:(t,e,o)=>{t.exports=o(846)},846:(t,e,o)=>{var r=o(960);e.operation=function(t){var o=e.timeouts(t);return new r(o,{forever:t&&(t.forever||t.retries===1/0),unref:t&&t.unref,maxRetryTime:t&&t.maxRetryTime})},e.timeouts=function(t){if(t instanceof Array)return[].concat(t);var e={retries:10,factor:2,minTimeout:1e3,maxTimeout:1/0,randomize:!1};for(var o in t)e[o]=t[o];if(e.minTimeout>e.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var r=[],n=0;n<e.retries;n++)r.push(this.createTimeout(n,e));return t&&t.forever&&!r.length&&r.push(this.createTimeout(n,e)),r.sort((function(t,e){return t-e})),r},e.createTimeout=function(t,e){var o=e.randomize?Math.random()+1:1,r=Math.round(o*Math.max(e.minTimeout,1)*Math.pow(e.factor,t));return Math.min(r,e.maxTimeout)},e.wrap=function(t,o,r){if(o instanceof Array&&(r=o,o=null),!r)for(var n in r=[],t)"function"==typeof t[n]&&r.push(n);for(var i=0;i<r.length;i++){var a=r[i],s=t[a];t[a]=function(r){var n=e.operation(o),i=Array.prototype.slice.call(arguments,1),a=i.pop();i.push((function(t){n.retry(t)||(t&&(arguments[0]=n.mainError()),a.apply(this,arguments))})),n.attempt((function(){r.apply(t,i)}))}.bind(t,s),t[a].options=o}}},960:t=>{function e(t,e){"boolean"==typeof e&&(e={forever:e}),this._originalTimeouts=JSON.parse(JSON.stringify(t)),this._timeouts=t,this._options=e||{},this._maxRetryTime=e&&e.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}t.exports=e,e.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},e.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},e.prototype.retry=function(t){if(this._timeout&&clearTimeout(this._timeout),!t)return!1;var e=(new Date).getTime();if(t&&e-this._operationStart>=this._maxRetryTime)return this._errors.push(t),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(t);var o=this._timeouts.shift();if(void 0===o){if(!this._cachedTimeouts)return!1;this._errors.splice(0,this._errors.length-1),o=this._cachedTimeouts.slice(-1)}var r=this;return this._timer=setTimeout((function(){r._attempts++,r._operationTimeoutCb&&(r._timeout=setTimeout((function(){r._operationTimeoutCb(r._attempts)}),r._operationTimeout),r._options.unref&&r._timeout.unref()),r._fn(r._attempts)}),o),this._options.unref&&this._timer.unref(),!0},e.prototype.attempt=function(t,e){this._fn=t,e&&(e.timeout&&(this._operationTimeout=e.timeout),e.cb&&(this._operationTimeoutCb=e.cb));var o=this;this._operationTimeoutCb&&(this._timeout=setTimeout((function(){o._operationTimeoutCb()}),o._operationTimeout)),this._operationStart=(new Date).getTime(),this._fn(this._attempts)},e.prototype.try=function(t){console.log("Using RetryOperation.try() is deprecated"),this.attempt(t)},e.prototype.start=function(t){console.log("Using RetryOperation.start() is deprecated"),this.attempt(t)},e.prototype.start=e.prototype.try,e.prototype.errors=function(){return this._errors},e.prototype.attempts=function(){return this._attempts},e.prototype.mainError=function(){if(0===this._errors.length)return null;for(var t={},e=null,o=0,r=0;r<this._errors.length;r++){var n=this._errors[r],i=n.message,a=(t[i]||0)+1;t[i]=a,a>=o&&(e=n,o=a)}return e}},272:t=>{"use strict";t.exports=e},422:e=>{"use strict";e.exports=t},28:t=>{"use strict";t.exports=o}},n={};function i(t){var e=n[t];if(void 0!==e)return e.exports;var o=n[t]={exports:{}};return r[t](o,o.exports,i),o.exports}i.d=(t,e)=>{for(var o in e)i.o(e,o)&&!i.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var a={};return(()=>{"use strict";i.r(a),i.d(a,{PyodideClient:()=>v,PyodideFatalErrorReloader:()=>b,defaultPyodideLoader:()=>u,initPyodide:()=>f,loadPyodideAndPackage:()=>h,makeRunnerCallback:()=>y,pyodideExpose:()=>g,versionInfo:()=>m});var t=i(353);const e=new Set(["Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed"]);class o extends Error{constructor(t){super(),t instanceof Error?(this.originalError=t,({message:t}=t)):(this.originalError=new Error(t),this.originalError.stack=this.stack),this.name="AbortError",this.message=t}}const r=t=>void 0===globalThis.DOMException?new Error(t):new DOMException(t);async function n(n,i){return new Promise(((a,s)=>{i={onFailedAttempt(){},retries:10,...i};const l=t.operation(i);l.attempt((async t=>{try{a(await n(t))}catch(n){if(!(n instanceof Error))return void s(new TypeError(`Non-error was thrown: "${n}". You should only throw errors.`));if(n instanceof o)l.stop(),s(n.originalError);else if(n instanceof TypeError&&(r=n.message,!e.has(r)))l.stop(),s(n);else{((t,e,o)=>{const r=o.retries-(e-1);t.attemptNumber=e,t.retriesLeft=r})(n,t,i);try{await i.onFailedAttempt(n)}catch(t){return void s(t)}l.retry(n)||s(l.mainError())}}var r})),i.signal&&!i.signal.aborted&&i.signal.addEventListener("abort",(()=>{l.stop();const t=void 0===i.signal.reason?r("The operation was aborted."):i.signal.reason;s(t instanceof Error?t:r(t))}),{once:!0})}))}var s=i(422),l=i(272),p=i(28),c=function(t,e,o,r){return new(o||(o=Promise))((function(n,i){function a(t){try{l(r.next(t))}catch(t){i(t)}}function s(t){try{l(r.throw(t))}catch(t){i(t)}}function l(t){var e;t.done?n(t.value):(e=t.value,e instanceof o?e:new o((function(t){t(e)}))).then(a,s)}l((r=r.apply(t,e||[])).next())}))};const d=i(237).Z;function u(t=p.version){return c(this,void 0,void 0,(function*(){const e=`https://cdn.jsdelivr.net/pyodide/v${t}/full/`,o=yield(0,p.loadPyodide)({indexURL:e});if(o.version!==t)throw new Error(`loadPyodide loaded version ${o.version} instead of ${t}`);return o}))}function m(t){return t.split(".").map(Number)}function h(t,e=u){return c(this,void 0,void 0,(function*(){let o,r,{format:i,extractDir:a,url:s}=t;a=a||"/tmp/",[o,r]=yield Promise.all([n((()=>e()),{retries:3}),n((()=>function(t){return c(this,void 0,void 0,(function*(){if(_.has(t))return console.log("Loaded package from cache"),_.get(t);console.log("Fetching package from "+t.slice(0,100)+"...");const e=yield fetch(t);if(!e.ok)throw new Error(`Request for package failed with status ${e.status}: ${e.statusText}`);const o=yield e.arrayBuffer();return console.log("Fetched package"),_.set(t,o),o}))}(s)),{retries:3})]);const l=m(o.version);return o.unpackArchive(r,i,0===l[0]&&l[1]<=19?a:{extractDir:a}),o.pyimport("sys").path.append(a),f(o),o}))}function f(t){t.registerComlink(l);const e=t.pyimport("sys"),o=t.pyimport("pathlib"),r="/tmp/pyodide_worker_runner/";e.path.append(r),o.Path(r).mkdir(),o.Path(r+"pyodide_worker_runner.py").write_text(d),t.pyimport("pyodide_worker_runner")}const _=new Map;function y(t,e){return function(o,r){return r.toJs&&(r=r.toJs({dict_converter:Object.fromEntries})),"input"===o?(e.input&&e.input(r.prompt),t.readMessage()+"\n"):"sleep"!==o?"output"===o?e.output(r.parts):e.other(o,r):void t.syncSleep(1e3*r.seconds)}}function g(t){return(0,s.syncExpose)((function(e,o,...r){return c(this,void 0,void 0,(function*(){return t(Object.assign(Object.assign({},e),{interruptBuffer:o}),...r)}))}))}class v extends s.SyncClient{call(t,...e){const o=Object.create(null,{call:{get:()=>super.call}});return c(this,void 0,void 0,(function*(){let r=null;return"undefined"!=typeof SharedArrayBuffer&&(r=new Int32Array(new SharedArrayBuffer(1*Int32Array.BYTES_PER_ELEMENT)),this.interrupter=()=>{r[0]=2}),o.call.call(this,t,r,...e)}))}}class b{constructor(t){this.loader=t,this.pyodidePromise=t()}withPyodide(t){return c(this,void 0,void 0,(function*(){const e=yield this.pyodidePromise;try{return yield t(e)}catch(t){throw t.pyodide_fatal_error&&(this.pyodidePromise=this.loader()),t}}))}}})(),a})()));
//# sourceMappingURL=index.js.map